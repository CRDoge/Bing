<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport"
			content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>Bing Arbitrum - Eat my Bing</title>
		<link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon" />
		<link rel="stylesheet" href="static/css/swiper-bundle.min.css">
		<link rel="stylesheet" href="static/css/index.css">
		<link rel="stylesheet" href="static/css/animate.css">
		<link rel="stylesheet" href="static/css/bootstrap.css">
		<link rel="stylesheet" href="static/css/jquery.countdown.css">
		<script src="static/js/jquery-1.7.2.js"></script>
		<script src="static/js/swiper-bundle.min.js"></script>
		<script src="static/js/jquery.countdown.js"></script>

	</head>

	<body>
		<!-- header -->
		<div class="g-header">
			<div class="m-box">

				<div class="s-logo">
					<a href="index.html"><img src="static/picture/logo.png" alt="logo"></a>
				</div>
				<div class="cflex">
					<div class="s-nav s-pc">
						<ul>
							<li class="on"><a href="index.html">主页 </a></li>
							<li><a href="#a1">功能 </a></li>
							<li><a href="#a2">NFT </a></li>
							<li><a href="#a3">团队简介 </a></li>
							<li><a href="#a4">经济模型 </a></li>
							<li><a href="#a5">路线图 </a></li>


						</ul>
					</div>
				</div>
				<div class="s-menu s-wap"> <a href="javascript:void(0);" class="wap-menu"></a> </div>
			</div>
		</div>
		<!--wap-sub-->
		<div class="wap-sub s-wap">
			<div class="s-main">
				<div class="s-row">
					<h3><span><a href="index.html">主页</a></span><img src="static/picture/right-arrow.svg"
							alt="right-arrow"></h3>
				</div>

				<div class="s-row">
					<h3><span><a href="#a1">功能</a></span><img src="static/picture/right-arrow.svg"
							alt="right-arrow">
					</h3>
				</div>
				<div class="s-row">
					<h3><span><a href="#a2">NFT</a></span><img src="static/picture/right-arrow.svg"
							alt="right-arrow">
					</h3>
				</div>
				<div class="s-row">
					<h3><span><a href="#a3">团队简介</a></span><img src="static/picture/right-arrow.svg"
							alt="right-arrow">
					</h3>
				</div>
				<div class="s-row">
					<h3><span><a href="#a4">经济模型</a></span><img src="static/picture/right-arrow.svg"
							alt="right-arrow">
					</h3>
				</div>
				<div class="s-row">
					<h3><span><a href="#a5">路线图</a></span><img src="static/picture/right-arrow.svg"
							alt="right-arrow">
					</h3>
				</div>
			</div>
		</div>
		<script>
			var flag = true;

			jQuery(window).scroll(function(e) {
				if (jQuery(document).scrollTop() > 20) {
					$(".g-header").css({
						position: "fixed",
						"z-index": "998",
						width: "100%",
						background: 'rgba(255, 255, 255, 0.8)'
					});

				} else {


					$(".g-header").css({

						background: 'rgba(66, 66, 66, 0)'
					});

				}
			});
		</script>
		<!-- banner -->
		<div class="g-banner">

			<div class="m-box">
				<div class="m-c c-flex">
					<div class="s-info">
						<h1>Bing - 饼王
						</h1>
						<p>Bing Meme Token是加密货币领域中的一个独特存在。这个令牌具有无厘头和幽默的特点，是一个完全不同于其他加密货币的品种。每个Bing Meme Token都是一个不同的NFT，具有自己独特的图像和故事背景。它们没有保留，意味着每个人都有机会获得一个Bing Meme Token，并拥有一个独特的数字资产。Bing Meme Token是一个令人惊叹的数字资产，它有其独特的性质和魅力。无论是在加密货币领域还是数字艺术领域，Bing Meme Token都是一个值得关注和投资的对象。如果您想成为一个独特数字资产的持有者，并且想加入一个有趣和有活力的社区，请加入我们，并拥有属于您自己的Bing Meme Token！</p>
						<a href="https://arbiscan.io/address/0xe4E520E58e4e23c6D8fB947efFB9722b79413eEe#code" class="a-link">
							Arbitrum Scan
						</a>
						<a href="https://arbiscan.io/address/0xe4E520E58e4e23c6D8fB947efFB9722b79413eEe#code" class="a-link">
							Buy on Uniswap
						</a>
					</div>
					<div class="s-pic">
						<img src="static/picture/p1.png">
					</div>
				</div>
			</div>

		</div>
		<!--  -->
		<div class=" g-lb" id="a1">
			<div class="m-box">
				<div class="t2">
					<span>"链上去中心化的专属令牌"</span>
					<h1>Bing 饼王的优势特点</h1>
				</div>
				<div class="m-c">
					<ul>
						<li>
							<p>国内无厘头幽默是一种特殊的幽默形式，以离奇、荒谬、荒诞、诙谐、诡异等元素为特征，而且常常夹杂着幽默笑话和俚语。这种幽默形式往往能够引发观众的兴趣，让他们产生共鸣和愉悦感。在国内，画Bing已经成为一种流行的文化现象，并且在短时间内风靡全国。据不完全统计，国内的画Bing类节目和影视作品已经超过百部之多。其中，一些经典的无厘头幽默表现形式，如搞笑模仿、荒诞剧情、诙谐对白等，深受观众喜爱，成为了国内画Bing幽默热度排名前三的代表作品。画Bing的特点正是因为其独特的风格和表现形式，让人眼前一亮，倍感新奇。</p>
							<div class="img1">
								<img src="static/picture/p5.png">
							</div>
							<div class="img2">
								<img src="static/picture/p2.png">
							</div>
						</li>
						<li>
							<div class="img2">
								<img src="static/picture/p3.png">
							</div>
							<div class="img1">
								<img src="static/picture/p5.png">
							</div>
							<p>国内首款无厘头Memecoin Nft系列，将在加密货币领域中引起轰动，在数字艺术市场上迅速崛起。这款令牌的NFT系列不仅具有无与伦比的收藏价值，还展示了其独特的设计风格和无厘头的幽默感，让它成为数字艺术品市场上的一股新势力。每一个NFT令牌都是独一无二的，没有任何保留，因此具有稀缺性和珍贵性，成为数字艺术收藏家们的追捧之选。此外，令牌所采用的独特的节点系统，使得交易流程更为高效和安全，让投资者可以更加安心地购买和持有这款无厘头Memecoin Nft系列。作为国内无厘头幽默风趣热度排名前三的Bing，这款令牌的未来可谓一片光明，投资者们可以放心地持有和收藏。</p>
						</li>
						<li>
							<div class="img2">
								<img src="static/picture/p4.png">
							</div>
							<div class="img1">
								<img src="static/picture/p5.png">
							</div>
							<p>这是一个充满创新和凝聚力的项目，由众多社区纯共识地联合打造而成。项目在国内和国际上汇聚了大量的技术专家、区块链研究者和投资者，凭借其强大的社区支持和优秀的技术能力，成功地打造出了这款集Memecoin和NFT于一身的项目。在这个项目中，每一个节点都可以直接参与到项目的开发和运营中，充分发挥自身的技术和经验，助力项目的发展和壮大。这种集众大社区纯共识的模式，不仅确保了项目的公正性和透明性，也为项目的可持续发展打下了坚实的基础。</p>
						</li>
					</ul>
				</div>
			</div>
		</div>


		<!--  -->
		<div class="g-jj" id="a4">
			<div class="m-box">

				<div class="m-c">

					<h1>经济模型</h1>
					<p>
						代币简称: Bing<br> 总发行量: 100,000,000,000 <br>
						发行链: ARB (Arbitrum Chain)<br>
						流动性: Bing即将上线.
					</p>

				</div>
			</div>
		</div>


		<!--  -->
		<div class="g-gl" id="a3">
			<div class="m-box">
				<div class="t">
					<h1>团队简介</h1>

				</div>
				<div class="m-c">

					<ul>
						<li>
							<div class="l-l">
								<div class="txt">
									<span>买饼达人</span>
									<h1>山鸡哥</h1>

								</div>
								<div class="img">
									<img src="static/picture/r (1).jpg">
								</div>
							</div>
							<p>负责Bing整体产品开发和规划，拥有超过10年团队管理经验，6年以上创业团队经验。 精通区块链金融等新兴行业，金融科技、互联网金融等，具有完整的业务规划和
投资管理能力。 曾就职于世界500强吹牛逼科技公司IBM； 在2015年进入区块链领域，参与初期策划及3家区块链公司的布局。</p>

						</li>
						<li>
							<div class="l-l">
								<div class="txt">
									<span>买饼选手</span>
									<h1>阿giao</h1>

								</div>
								<div class="img">
									<img src="static/picture/r (2).jpg">
								</div>
							</div>
							<p>负责Bing全球营销策略，洞察全球市场机会，制定营销策略，带动产品和品牌影响力。 超过12年世界500强企业营销管理经验，帮助众多初创企业成功完成品牌形象转型。 精通互联网、电子商务和金融科技领域的品牌管理。 曾就职于USWeb等创新型互联网公司，实践经验丰富，多次成功塑造品牌影响力。以上纯属吹牛逼。</p>

						</li>
						<li>
							<div class="l-l">
								<div class="txt">
									<span>买饼爱好者</span>
									<h1>马斯克</h1>

								</div>
								<div class="img">
									<img src="static/picture/r (3).jpg">
								</div>
							</div>
							<p>负责产品区块链结构设计，精通各种主流共识算法； 精通区块链系统开发语言。 他在互联网游戏开发和区块链技术方面拥有超过 150 年的经验。 2012年至今多次进行区块链技术创业，参与了2个交易所和1个数字钱包项目的上市。 曾就职于BTCJam、Changetip等专业区块链支付公司。我靠我都快信了，起猛了，再睡会。</p>

						</li>
						<li>
							<div class="l-l">
								<div class="txt">
									<span>我就是饼</span>
									<h1>饼王</h1>

								</div>
								<div class="img">
									<img src="static/picture/r (4).jpg">
								</div>
							</div>
							<p>负责Bing全球市场运营，根据集团总体战略规划，组织制定Bing业务运营发展规划和中长期规划； 推动公司的全球战略和项目实施。 拥有超过13年的经营管理经验， 主要从事互联网和电子商务领域的市场运作，善于处理和应对各类复杂的商业问题，与各类金融机构（银行、信托、创投、股权投资）合作机构）。这是真实的。</p>

						</li>

					</ul>

				</div>
			</div>
		</div>
		<!--  -->
		<div class="g-tone" id="a5">
			<div class="m-box">
				<div class="t">
					<h1>发展路线图</h1>

				</div>
				<div class="m-c c-flex">
					
					<p>什<br>
					么<br>
						 鸡<br>
						 巴<br>
						发<br>
						展<br>
						路<br>
						线<br>
						都<br>
						没<br>
						有<br>
						的<br>，社区未来想往哪里走就往哪里走，LP全扔，一起做吃Bing家人
						</p>
					<div class="s-pic">
						<img src="static/picture/p7.jpg">
					</div>
					
				</div>
			</div>
		</div>
		<!--  -->
		

		
		<!--  -->
		<div class="g-hz" id="a5">
			<div class="m-box">
				<div class="tit">
					<h1>Cooperative institutions</h1>
					
				</div>
				<div class="m-c">
					<ul>
						<li>
							<img src="static/picture/hz (1).png">
						</li>
						<li>
							<img src="static/picture/hz (2).png">
						</li>
						<li>
							<img src="static/picture/hz (3).png">
						</li>
						<li>
							<img src="static/picture/hz (4).png">
						</li>
						<li>
							<img src="static/picture/hz (5).png">
						</li>
						<li>
							<img src="static/picture/hz (6).png">
						</li>
						<li>
							<img src="static/picture/hz (7).png">
						</li>
						<li>
							<img src="static/picture/hz (8).png">
						</li>
						<li>
							<img src="static/picture/hz (9).png">
						</li>
						<li>
							<img src="static/picture/hz (10).png">
						</li>
						<li>
							<img src="static/picture/hz (11).png">
						</li>
						<li>
							<img src="static/picture/hz (12).png">
						</li>
						<li>
							<img src="static/picture/hz (13).png">
						</li>
						<li>
							<img src="static/picture/hz (14).png">
						</li>
						<li>
							<img src="static/picture/hz (15).png">
						</li>
						<li>
							<img src="static/picture/hz (16).png">
						</li>
						
					</ul>
				</div>
			</div>
		</div>
		<!-- footer -->
		<div class="g-footer" id="a6">
			<div class="m-box">

				<div class=" m-c1">


					<div class="s-info">

						<ul>
							<li> <a href="https://twitter.com/Bing_Arb">
									<img src="static/picture/f (1).png" alt="share"></a> </li>
							<li> <a href="https://t.me/BingArb8">
									<img src="static/picture/f (2).png" alt="share"></a>
							</li>
							<!--<li> <a href="#">-->
							<!--		<img src="static/picture/f (3).png" alt="share"></a>-->
							<!--</li>-->
							<!--<li> <a href="#">-->
							<!--		<img src="static/picture/f (4).png" alt="share"></a>-->
							<!--</li>-->

						</ul>
					</div>

				</div>
				<br><br><br><br>
				<p>Copyright @ Bing. All Rights Reserved. </p>

			</div>
		</div>


		<div class="waves"></div>


		<script src="static/js/index.js"></script>
		<script src="static/js/echarts.js"></script>
		<script>
			var myChart3 = echarts.init(document.getElementById('main3'));

			myChart3.setOption({
				tooltip: {
					trigger: 'item',
					formatter: '{a} <br/>{b} : {c} ({d}%)'
				},
				series: [{

					type: 'pie',
					radius: ['50%', '80%'],
					avoidLabelOverlap: false,
					selectedMode: 'single',
					label: {
						"normal": {
							"show": true,
							"textStyle": {
								"fontSize": 14,
								"color": "#fff"
							}
						},
						"emphasis": {
							"show": true
						}
					},
					labelLine: {
						show: true
					},
					data: [{
						value: 4,
						name: '4%Foundation'
					}, {
						value: 18.8,
						name: '18.8% DAO Comunity'
					}, {
						value: 1,
						name: '1%Technology ',
					}, {
						value: 72.8,
						name: '72.8% Ecological Output',
					}, {
						value: 3.4,
						name: '3.4% Rewards',
					}],
					/* roseType: 'area', */
					itemStyle: {
						normal: {
							borderRadius: 10,
							borderColor: '#001527',
							borderWidth: 2,
							areaColor: 'rgba(65, 82, 245, 0.2)',
							fontSize: '40',
							color: function(params) {
								var colorList = ['#f2f2f2', '#1a1a1a', '#01fefe', '#01fefd', '#00a99d',
									'#6b9ad0', '#ebeaea'
								];

								return colorList[params.dataIndex]
							},
						}
					}
				}]
			});
		</script>

		<script>
			class ShaderProgram {

				constructor(holder, options = {}) {

					options = Object.assign({
						antialias: false,
						depthTest: false,
						mousemove: false,
						autosize: true,
						side: 'front',
						vertex: `
		        precision highp float;
		
		        attribute vec4 a_position;
		        attribute vec4 a_color;
		
		        uniform float u_time;
		        uniform vec2 u_resolution;
		        uniform vec2 u_mousemove;
		        uniform mat4 u_projection;
		
		        varying vec4 v_color;
		
		        void main() {
		
		          gl_Position = u_projection * a_position;
		          gl_PointSize = (10.0 / gl_Position.w) * 100.0;
		
		          v_color = a_color;
		
		        }`,
						fragment: `
		        precision highp float;
		
		        uniform sampler2D u_texture;
		        uniform int u_hasTexture;
		
		        varying vec4 v_color;
		
		        void main() {
		
		          if ( u_hasTexture == 1 ) {
		
		            gl_FragColor = v_color * texture2D(u_texture, gl_PointCoord);
		
		          } else {
		
		            gl_FragColor = v_color;
		
		          }
		
		        }`,
						uniforms: {},
						buffers: {},
						camera: {},
						texture: null,
						onUpdate: (() => {}),
						onResize: (() => {}),
					}, options)

					const uniforms = Object.assign({
						time: {
							type: 'float',
							value: 0
						},
						hasTexture: {
							type: 'int',
							value: 0
						},
						resolution: {
							type: 'vec2',
							value: [0, 0]
						},
						mousemove: {
							type: 'vec2',
							value: [0, 0]
						},
						projection: {
							type: 'mat4',
							value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
						},
					}, options.uniforms)

					const buffers = Object.assign({
						position: {
							size: 3,
							data: []
						},
						color: {
							size: 4,
							data: []
						},
					}, options.buffers)

					const camera = Object.assign({
						fov: 60,
						near: 1,
						far: 10000,
						aspect: 1,
						z: 100,
						perspective: true,
					}, options.camera)

					const canvas = document.createElement('canvas')
					const gl = canvas.getContext('webgl', {
						antialias: options.antialias
					})

					if (!gl) return false

					this.count = 0
					this.gl = gl
					this.canvas = canvas
					this.camera = camera
					this.holder = holder
					this.onUpdate = options.onUpdate
					this.onResize = options.onResize
					this.data = {}

					holder.appendChild(canvas)

					this.createProgram(options.vertex, options.fragment)

					this.createBuffers(buffers)
					this.createUniforms(uniforms)

					this.updateBuffers()
					this.updateUniforms()

					this.createTexture(options.texture)

					gl.enable(gl.BLEND)
					gl.enable(gl.CULL_FACE)
					gl.blendFunc(gl.SRC_ALPHA, gl.ONE)
					gl[options.depthTest ? 'enable' : 'disable'](gl.DEPTH_TEST)

					if (options.autosize)
						window.addEventListener('resize', e => this.resize(e), false)
					if (options.mousemove)
						window.addEventListener('mousemove', e => this.mousemove(e), false)

					this.resize()

					this.update = this.update.bind(this)
					this.time = {
						start: performance.now(),
						old: performance.now()
					}
					this.update()

				}

				mousemove(e) {

					let x = e.pageX / this.width * 2 - 1
					let y = e.pageY / this.height * 2 - 1

					this.uniforms.mousemove = [x, y]

				}

				resize(e) {

					const holder = this.holder
					const canvas = this.canvas
					const gl = this.gl

					const width = this.width = holder.offsetWidth
					const height = this.height = holder.offsetHeight
					const aspect = this.aspect = width / height
					const dpi = this.dpi = devicePixelRatio

					canvas.width = width * dpi
					canvas.height = height * dpi
					canvas.style.width = width + 'px'
					canvas.style.height = height + 'px'

					gl.viewport(0, 0, width * dpi, height * dpi)
					gl.clearColor(0, 0, 0, 0)

					this.uniforms.resolution = [width, height]
					this.uniforms.projection = this.setProjection(aspect)

					this.onResize(width, height, dpi)

				}

				setProjection(aspect) {

					const camera = this.camera

					if (camera.perspective) {

						camera.aspect = aspect

						const fovRad = camera.fov * (Math.PI / 180)
						const f = Math.tan(Math.PI * 0.5 - 0.5 * fovRad)
						const rangeInv = 1.0 / (camera.near - camera.far)

						const matrix = [
							f / camera.aspect, 0, 0, 0,
							0, f, 0, 0,
							0, 0, (camera.near + camera.far) * rangeInv, -1,
							0, 0, camera.near * camera.far * rangeInv * 2, 0
						]

						matrix[14] += camera.z
						matrix[15] += camera.z

						return matrix

					} else {

						return [
							2 / this.width, 0, 0, 0,
							0, -2 / this.height, 0, 0,
							0, 0, 1, 0,
							-1, 1, 0, 1,
						]

					}

				}

				createShader(type, source) {

					const gl = this.gl
					const shader = gl.createShader(type)

					gl.shaderSource(shader, source)
					gl.compileShader(shader)

					if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {

						return shader

					} else {

						console.log(gl.getShaderInfoLog(shader))
						gl.deleteShader(shader)

					}

				}

				createProgram(vertex, fragment) {

					const gl = this.gl

					const vertexShader = this.createShader(gl.VERTEX_SHADER, vertex)
					const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragment)

					const program = gl.createProgram()

					gl.attachShader(program, vertexShader)
					gl.attachShader(program, fragmentShader)
					gl.linkProgram(program)

					if (gl.getProgramParameter(program, gl.LINK_STATUS)) {

						gl.useProgram(program)
						this.program = program

					} else {

						console.log(gl.getProgramInfoLog(program))
						gl.deleteProgram(program)

					}

				}

				createUniforms(data) {

					const gl = this.gl
					const uniforms = this.data.uniforms = data
					const values = this.uniforms = {}

					Object.keys(uniforms).forEach(name => {

						const uniform = uniforms[name]

						uniform.location = gl.getUniformLocation(this.program, 'u_' + name)

						Object.defineProperty(values, name, {
							set: value => {

								uniforms[name].value = value
								this.setUniform(name, value)

							},
							get: () => uniforms[name].value
						})

					})

				}

				setUniform(name, value) {

					const gl = this.gl
					const uniform = this.data.uniforms[name]

					uniform.value = value

					switch (uniform.type) {
						case 'int': {
							gl.uniform1i(uniform.location, value)
							break
						}
						case 'float': {
							gl.uniform1f(uniform.location, value)
							break
						}
						case 'vec2': {
							gl.uniform2f(uniform.location, ...value)
							break
						}
						case 'vec3': {
							gl.uniform3f(uniform.location, ...value)
							break
						}
						case 'vec4': {
							gl.uniform4f(uniform.location, ...value)
							break
						}
						case 'mat2': {
							gl.uniformMatrix2fv(uniform.location, false, value)
							break
						}
						case 'mat3': {
							gl.uniformMatrix3fv(uniform.location, false, value)
							break
						}
						case 'mat4': {
							gl.uniformMatrix4fv(uniform.location, false, value)
							break
						}
					}

					// ivec2       : uniform2i,
					// ivec3       : uniform3i,
					// ivec4       : uniform4i,
					// sampler2D   : uniform1i,
					// samplerCube : uniform1i,
					// bool        : uniform1i,
					// bvec2       : uniform2i,
					// bvec3       : uniform3i,
					// bvec4       : uniform4i,

				}

				updateUniforms() {

					const gl = this.gl
					const uniforms = this.data.uniforms

					Object.keys(uniforms).forEach(name => {

						const uniform = uniforms[name]

						this.uniforms[name] = uniform.value

					})

				}

				createBuffers(data) {

					const gl = this.gl
					const buffers = this.data.buffers = data
					const values = this.buffers = {}

					Object.keys(buffers).forEach(name => {

						const buffer = buffers[name]

						buffer.buffer = this.createBuffer('a_' + name, buffer.size)

						Object.defineProperty(values, name, {
							set: data => {

								buffers[name].data = data
								this.setBuffer(name, data)

								if (name == 'position')
									this.count = buffers.position.data.length / 3

							},
							get: () => buffers[name].data
						})

					})

				}

				createBuffer(name, size) {

					const gl = this.gl
					const program = this.program

					const index = gl.getAttribLocation(program, name)
					const buffer = gl.createBuffer()

					gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
					gl.enableVertexAttribArray(index)
					gl.vertexAttribPointer(index, size, gl.FLOAT, false, 0, 0)

					return buffer

				}

				setBuffer(name, data) {

					const gl = this.gl
					const buffers = this.data.buffers

					if (name == null && !gl.bindBuffer(gl.ARRAY_BUFFER, null)) return

					gl.bindBuffer(gl.ARRAY_BUFFER, buffers[name].buffer)
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)

				}

				updateBuffers() {

					const gl = this.gl
					const buffers = this.buffers

					Object.keys(buffers).forEach(name =>
						buffers[name] = buffer.data
					)

					this.setBuffer(null)

				}

				createTexture(src) {

					const gl = this.gl
					const texture = gl.createTexture()

					gl.bindTexture(gl.TEXTURE_2D, texture)
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0,
						0
					]))

					this.texture = texture

					if (src) {

						this.uniforms.hasTexture = 1
						this.loadTexture(src)

					}

				}

				loadTexture(src) {

					const gl = this.gl
					const texture = this.texture

					const textureImage = new Image()

					textureImage.onload = () => {

						gl.bindTexture(gl.TEXTURE_2D, texture)

						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage)

						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)

						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

						// gl.generateMipmap( gl.TEXTURE_2D )

					}

					textureImage.src = src

				}

				update() {

					const gl = this.gl

					const now = performance.now()
					const elapsed = (now - this.time.start) / 5000
					const delta = now - this.time.old
					this.time.old = now

					this.uniforms.time = elapsed

					if (this.count > 0) {
						gl.clear(gl.COLORBUFFERBIT)
						gl.drawArrays(gl.POINTS, 0, this.count)
					}

					this.onUpdate(delta)

					requestAnimationFrame(this.update)

				}

			}

			const pointSize = 2.5

			const waves = new ShaderProgram(document.querySelector('.waves'), {
				texture: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAb1BMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8v0wLRAAAAJHRSTlMAC/goGvDhmwcExrVjWzrm29TRqqSKenRXVklANSIUE8mRkGpv+HOfAAABCElEQVQ4y4VT13LDMAwLrUHteO+R9f/fWMfO6dLaPeKVEECRxOULWsEGpS9nULDwia2Y+ALqUNbAWeg775zv+sA4/FFRMxt8U2FZFCVWjR/YrH4/H9sarclSKdPMWKzb8VsEeHB3m0shkhVCyNzeXeAQ9Xl4opEieX2QCGnwGbj6GMyjw9t1K0fK9YZunPXeAGsfJtYjwzxaBnozGGorYz0ypK2HzQSYx1y8DgSRo2ewOiyh2QWOEk1Y9OrQV0a8TiBM1a8eMHWYnRMy7CZ4t1CmyRkhSUvP3gRXyHOCLBxNoC3IJv//ZrJ/kxxUHPUB+6jJZZHrpg6GOjnqaOmzp4NDR48OLxn/H27SRQ08S0ZJAAAAAElFTkSuQmCC',
				uniforms: {
					size: {
						type: 'float',
						value: pointSize
					},
					field: {
						type: 'vec3',
						value: [0, 0, 0]
					},
					speed: {
						type: 'float',
						value: 5
					},
				},
				vertex: `
		    #define M_PI 3.1415926535897932384626433832795
		
		    precision highp float;
		
		    attribute vec4 a_position;
		    attribute vec4 a_color;
		
		    uniform float u_time;
		    uniform float u_size;
		    uniform float u_speed;
		    uniform vec3 u_field;
		    uniform mat4 u_projection;
		
		    varying vec4 v_color;
		
		    void main() {
		
		      vec3 pos = a_position.xyz;
		
		      pos.y += (
		        cos(pos.x / u_field.x * M_PI * 8.0 + u_time * u_speed) +
		        sin(pos.z / u_field.z * M_PI * 8.0 + u_time * u_speed)
		      ) * u_field.y;
		
		      gl_Position = u_projection * vec4( pos.xyz, a_position.w );
		      gl_PointSize = ( u_size / gl_Position.w ) * 100.0;
		
		      v_color = a_color;
		
		    }`,
				fragment: `
		    precision highp float;
		
		    uniform sampler2D u_texture;
		
		    varying vec4 v_color;
		
		    void main() {
		
		      gl_FragColor = v_color * texture2D(u_texture, gl_PointCoord);
		
		    }`,
				onResize(w, h, dpi) {

					const position = [],
						color = []

					const width = 400 * (w / h)
					const depth = 400
					const height = 3
					const distance = 5

					for (let x = 0; x < width; x += distance) {
						for (let z = 0; z < depth; z += distance) {

							position.push(-width / 2 + x, -30, -depth / 2 + z)
							color.push(0, 1 - (x / width) * 1, 0.5 + x / width * 0.5, z / depth)

						}
					}

					this.uniforms.field = [width, height, depth]

					this.buffers.position = position
					this.buffers.color = color

					this.uniforms.size = (h / 400) * pointSize * dpi

				},
			})
		</script>

	</body>
</html>
